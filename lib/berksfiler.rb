require "berksfiler/version"

module Berksfiler
  require 'yaml'

  # Berksfiler programatically generates Berksfiles with correct dependencies
  class Berksfiler
   REPO_ROOT = File.expand_path(File.join(File.expand_path(__FILE__), '..', '..'))
   COOKBOOK_ROOT = File.expand_path(File.join(REPO_ROOT, 'cookbooks'))
   CONFIG_FILE = File.join(REPO_ROOT, 'config', 'berksfiler.yml')

   EXCLUDED_DIRS_REGEX = /^\./  # reject . and .. directories when globbing the cookbooks dir

   BERKSFILE_FRONTMATTER = "# Autogenerated by Berksfiler, do not edit\n\nsource 'https://supermarket.getchef.com'\nmetadata\n\n"

   attr_reader :config, :local_cookbooks, :git_cookbooks, :git_cookbook_urls

   def initialize
     @config = YAML.load_file(CONFIG_FILE)
     @git_cookbooks = @config['git_cookbooks'].map { |cb| cb['name'] }
     @git_cookbook_urls = {}
     @config['git_cookbooks'].each { |cb| @git_cookbook_urls[cb['name']] = cb['url'] }
     @local_cookbooks = local_cookbooks
   end

   # returns an array of all local cookbooks (basically a directory listing of the COOKBOOT_ROOT)
   def local_cookbooks
     Dir.entries(COOKBOOK_ROOT).reject { |dir| dir =~ EXCLUDED_DIRS_REGEX }
   end

   # returns an array of all cookbook dependencies for a given cookbook by running `knife deps`
   def get_deps(cookbook)
     raw_deps = `knife deps cookbooks/#{cookbook} --remote`.split("\n") # ["cookbooks/apt", "cookbooks/chef_handler", "cookbooks/cozy-chef_handler"]
     raw_deps.map { |cb| cb.split('/')[1].strip } # ["apt", "chef_handler", "cozy-chef_handler"]
   end

   # returns an array of cookbook dependencies for a given cookbook,
   # limited to cookbooks which exist in the local COOKBOOK_ROOT or are specified
   # in `git_cookbooks` in the config file.
   def get_local_deps(cookbook)
     all_deps = get_deps(cookbook)
     local_cookbooks = @local_cookbooks.reject { |cb| cb == cookbook } # don't include self
     all_deps.select { |cb| local_cookbooks.include?(cb) || @git_cookbooks.include?(cb) }
   end

   # generate a berksfile line for a community cookbook
   def community_cookbook_line(cookbook)
     "cookbook '#{cookbook}'\n"
   end

   # generate a berksfile line for a git-sourced cookbook
   def git_cookbook_line(cookbook)
     "cookbook '#{cookbook}', git: '#{@git_cookbook_urls[cookbook]}'\n"
   end

   # generate a berksfile line for a local path-sourced cookbook
   def path_cookbook_line(cookbook)
     "cookbook '#{cookbook}', path: '../#{cookbook}'\n"
   end

   # generate a berksfile line for a cookbook by determining the correct source
   def cookbook_line(cookbook)
     if @git_cookbooks.include?(cookbook)
       git_cookbook_line(cookbook)
     elsif @local_cookbooks.include?(cookbook)
       path_cookbook_line(cookbook)
     else
       community_cookbook_line(cookbook)
     end
   end

   # generate a full berksfile for a cookbook, including all dependencies with their correct sources.
   # Excludes community cookbooks unless they are specified in `common_cookbooks`, because the
   # `metadata` directive handles these includes.
   def generate_berksfile(deps)
     content = ''
     content << BERKSFILE_FRONTMATTER

     @config['common_cookbooks'].each { |cb| content << cookbook_line(cb) }
     deps.each { |cb| content << cookbook_line(cb) }

     content
   end

   # Generate a berksfile and emplace it in a +cookbook+
   def emplace_berksfile(cookbook)
     puts "Generating Berksfile for local cookbook '#{cookbook}'"
     content = generate_berksfile(get_local_deps(cookbook))
     open(File.join(COOKBOOK_ROOT, cookbook, 'Berksfile'), 'w') do |f|
       f << content
     end
   end

   # for all local cookbooks, excluding `excluded_cookbooks`, calculate all dependencies
   # and programmatically generate a Berksfile for that cookbook which takes into account
   # the correct sources for all dependencies.
   def run
     managed_cookbooks = @local_cookbooks.reject { |cb| @config['excluded_cookbooks'].include?(cb) }
     managed_cookbooks.each do |cb|
       emplace_berksfile(cb)
     end
   end

  end

end
