module Berksfiler
  # Methods for generating a Berksfile
  class Generator
    BERKSFILE_FRONTMATTER = "# Autogenerated by Berksfiler, do not edit\n\nsource 'https://supermarket.chef.io'\nmetadata\n\n"

    # returns an array of all cookbook dependencies for a given cookbook by running `knife deps`
    def self::get_deps(cookbook)
      raw_deps = `knife deps cookbooks/#{cookbook} --remote`.split("\n") # ["cookbooks/apt", "cookbooks/chef_handler", "cookbooks/cozy-chef_handler"]
      raw_deps.map { |cb| cb.split('/')[1].strip } # ["apt", "chef_handler", "cozy-chef_handler"]
    end

    # returns an array of cookbook dependencies for a given cookbook,
    # limited to cookbooks which are are local or have specific options
    def self::get_local_deps(cookbook)
      all_deps = get_deps(cookbook)
      local_cookbooks = Berksfiler.specific_cookbooks.reject { |cb| cb == cookbook } # don't include self
      all_deps.select { |cb| local_cookbooks.include?(cb) }
    end

    # generate a full berksfile for a cookbook, including all dependencies with their correct sources.
    # Excludes community cookbooks unless they are specified in `common_cookbooks`, because the
    # `metadata` directive handles these includes.
    def self::generate_berksfile(cookbook)
      content = ''
      content << BERKSFILE_FRONTMATTER

      common_cookbooks = Berksfiler.common_cookbooks.map { |cb| Formatter.cookbook_line(cb).split(' ') }
      unless common_cookbooks.empty?
        content << "# Common dependencies for all Berksfiles\n"
        content << Formatter.aligned_print(common_cookbooks.sort).join("\n")
        content << "\n"
      end

      cookbooks = get_local_deps(cookbook).map { |cb| Formatter.cookbook_line(cb).split(' ') }
      unless cookbooks.empty?
        content << "\n# Dependencies of this cookbook\n"
        content << Formatter.aligned_print(cookbooks.sort).join("\n")
        content << "\n"
      end
      content
    end
  end
end
